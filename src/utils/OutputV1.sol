pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../token/stFlip.sol";
import "../utils/BurnerV1.sol";
import "../mock/StateChainGateway.sol";
import "../utils/Ownership.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";


contract OutputV1 is Initializable, Ownership {

    mapping (bytes32 => bool) public validators;

    StateChainGateway public stateChainGateway;
    BurnerV1 public wrappedBurnerProxy;
    IERC20 public flip;

    constructor () {
        _disableInitializers();
    }

    function initialize(address flip_, address burnerProxy_, address gov_,  address manager_, address stateChainGateway_,address rebaser_) initializer public {
        flip = IERC20(flip_);
        wrappedBurnerProxy = BurnerV1(burnerProxy_);

        __AccessControlDefaultAdminRules_init(0, gov_);
        _grantRole(MANAGER_ROLE, gov_);
        _grantRole(MANAGER_ROLE, manager_);

        stateChainGateway = StateChainGateway(stateChainGateway_);
        
        flip.approve(address(rebaser_), 2**256-1);
        flip.approve(address(wrappedBurnerProxy), 2**256 - 1);
        flip.approve(address(stateChainGateway), 2**256 - 1);

    }

    /** Adds validators so that they can be staked to
     * @param addresses The list of addresses to add to the map
     * @dev it should be ensured prior to adding validators to the map
     * that there was a state chain transaction submitted that sets the
     * withdrawal address to the output address to ensure non-custodial
     */
    function addValidators(bytes32[] calldata addresses) external onlyRole(DEFAULT_ADMIN_ROLE) {
        for (uint256 i = 0; i < addresses.length; i++) {
            validators[addresses[i]] = true;
        }
    }

    /** Removes validators that can be staked to
     * @param addresses The list of addresses to remove from the map
     */
    function removeValidators(bytes32[] calldata addresses) external onlyRole(DEFAULT_ADMIN_ROLE) {
        for (uint256 i = 0; i < addresses.length; i++) {
            delete validators[addresses[i]];
        }
    }

    /** Funds state chain accounts 
     * @param addresses The list of Chainflip validator addresses to fund (hex version)
     * @param amounts The list of amounts to fund each address with
     * @dev Only addresses in the `validators` map can be funded. 
     */
    function fundValidators(bytes32[] calldata addresses, uint256[] calldata amounts) external onlyRole(MANAGER_ROLE) {
        require(addresses.length == amounts.length, "lengths must match");
        for (uint i = 0; i < addresses.length; i++) {
            require(validators[addresses[i]] == true, "Output: address not added");
            stateChainGateway.fundStateChainAccount(addresses[i], amounts[i]);
        }
    }

    /** Redeems funds from state chain accounts
     * @param addresses The list of Chainflip validator to redeem
     * @dev The redemptions must be first generated by the validators
     * on the Chainflip side
     */
    function redeemValidators(bytes32[] calldata addresses) external onlyRole(MANAGER_ROLE) {
        for (uint i = 0; i < addresses.length; i++) {
            stateChainGateway.executeRedemption(addresses[i]);
        }
    }

}








