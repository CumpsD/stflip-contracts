pragma solidity 0.8.18;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../token/stFlip.sol";
import "../utils/BurnerV1.sol";
import "../mock/StateChainGateway.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";


contract OutputV1 is Initializable {
    using SafeMath for uint256;

    address public gov;
    address public pendingGov;
    address public manager;

    mapping (bytes32 => uint8) public validators;

    StateChainGateway public stateChainGateway;
    BurnerV1 public wrappedBurnerProxy;
    IERC20 public flip;

    constructor () {
        _disableInitializers();
    }

    function initialize(address flip_,
                        address burnerProxy_, 
                        address gov_,  
                        address manager_, 
                        address stateChainGateway_,
                        address rebaser_) initializer public {
        flip = IERC20(flip_);
        wrappedBurnerProxy = BurnerV1(burnerProxy_);
        gov = gov_;
        manager = manager_;
        stateChainGateway = StateChainGateway(stateChainGateway_);
        
        flip.approve(address(rebaser_), 2**256-1);
        flip.approve(address(wrappedBurnerProxy), 2**256 - 1);
        flip.approve(address(stateChainGateway), 2**256 - 1);

    }

    /**
     * @notice Event emitted when pendingGov is changed
     */
    event NewPendingGov(address oldPendingGov, address newPendingGov);

    /**
     * @notice Event emitted when gov is changed
     */
    event NewGov(address oldGov, address newGov);

    /**
     * @notice Tokens burned event
     */
    event Burn(uint256 amount, uint256 burn_id);

    // Modifiers
    modifier onlyGov() {
        require(msg.sender == gov, "Output: not gov");
        _;
    }

    /** @notice sets the pendingGov
     * @param pendingGov_ The address of the rebaser contract to use for authentication.
     */
    function _setPendingGov(address pendingGov_) external onlyGov {
        address oldPendingGov = pendingGov;
        pendingGov = pendingGov_;
        emit NewPendingGov(oldPendingGov, pendingGov_);
    }

    /** @notice lets msg.sender accept governance
     *
     */
    function _acceptGov() external {
        require(msg.sender == pendingGov, "!pending");
        address oldGov = gov;
        gov = pendingGov;
        pendingGov = address(0);
        emit NewGov(oldGov, gov);
    }

    modifier onlyManager() {
        require(msg.sender == manager || msg.sender == gov, "Output: not manager or gov");
        _;
    }

    /** Sets the manager address
     * @param manager_ The address that can stake/unstake
     */
    function setManager(address manager_) external onlyGov {
        manager = manager_;
    }

    /** Adds validators so that they can be staked to
     * @param addresses The list of addresses to add to the map
     * @dev it should be ensured prior to adding validators to the map
     * that there was a state chain transaction submitted that sets the
     * withdrawal address to the output address to ensure non-custodial
     */
    function addValidators(bytes32[] calldata addresses) external onlyGov {
        for (uint256 i = 0; i < addresses.length; i++) {
            validators[addresses[i]] = 1;
        }
    }

    /** Removes validators that can be staked to
     * @param addresses The list of addresses to remove from the map
     */
    function removeValidators(bytes32[] calldata addresses) external onlyGov {
        for (uint256 i = 0; i < addresses.length; i++) {
            delete validators[addresses[i]];
        }
    }

    /** Funds state chain accounts 
     * @param addresses The list of Chainflip validator addresses to fund (hex version)
     * @param amounts The list of amounts to fund each address with
     * @dev Only addresses in the `validators` map can be funded. 
     */
    function fundValidators(bytes32[] calldata addresses, uint256[] calldata amounts) external onlyManager{
        require(addresses.length == amounts.length, "lengths must match");
        for (uint i = 0; i < addresses.length; i++) {
            require(validators[addresses[i]] == 1, "Output: address not added");
            stateChainGateway.fundStateChainAccount(addresses[i], amounts[i]);
        }
    }

    /** Redeems funds from state chain accounts
     * @param addresses The list of Chainflip validator to redeem
     * @dev The redemptions must be first generated by the validators
     * on the Chainflip side
     */
    function redeemValidators(bytes32[] calldata addresses) external onlyManager {
        for (uint i = 0; i < addresses.length; i++) {
            stateChainGateway.executeRedemption(addresses[i]);
        }
    }

    /// will be deprecated before mainnet
    function govWithdraw(address token, uint256 amount) external onlyGov {
        IERC20(token).transfer(msg.sender, amount);
    }

}








